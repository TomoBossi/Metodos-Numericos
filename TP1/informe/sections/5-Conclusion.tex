\section{Conclusiones}

Se diseñaron e implementaron algoritmos de EG para resolución de sistemas de ecuaciones lineales en Python, sin el uso de bibliotecas de álgebra lineal como Numpy o afines. Entre ellos, se diseñó un algoritmo de EG con pivoteo parcial (intercambio entre filas) que disminuye el error numérico, permite encontrar la solución de más sistemas, y no incrementa considerablemente la complejidad algoritmica respecto al algoritmo sin pivoteo, siendo ambos $O(n^3)$.

Aprovechando la estructura rala particular de las matrices tridiagonales, fue posible diseñar un algoritmo de EG de complejidad $O(n)$ que convierte a un sistema tridiagonal en uno equivalente diagonal a partir del cual es trivial encontrar la solución. Resolviendo sistemas tridiagonales dados por la matriz de la aproximación discreta al operador Laplaciano y varios vectores de términos independientes, se logró efectivamente encontrar aproximaciones discretas a funciones a partir de sus derivadas segundas.

Fue posible mejorar el algoritmo de EG para matrices tridiagonales de forma tal de permitir el precómputo de su sistema diagonal equivalente, permitiendo una disminución en tiempo de cómputo considerable para casos en los que es necesario reutilizar a una misma matriz de coeficientes para operar sobre una serie de vectores de términos independientes. Este último fue por ejemplo el caso de la simulación del proceso físico de difusión. Partiendo de la matriz tridiagonal asociada a la aproximación discreta a la ecuación de difusión, se precomputó su sistema diagonal equivalente y se lo resolvió iterativamente a partir de una condición inicial, efectivamente simulando la evolución temporal de la difusión a lo largo de un segmento lineal del espacio.

Para la cuantificación de los tiempos de cómputo de los distintos algoritmos se eligió una métrica robusta, el tiempo mínimo de los promedios de múltiples grupos de ejecuciones, mucho menos sensible al ruido propio del entorno en el que se ejecuta el código que otras como son el tiempo promedio. La medición de los tiempos nos permitió comprobar nuestros saberes previos acerca de cuales algoritmos esperabamos sean más rápidos, y con qué complejidades algorítmicas.